<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Track & Field Performance Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d35 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: rgba(15, 20, 40, 0.9);
            padding: 20px 30px;
            border-bottom: 2px solid #2a3f5f;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 28px;
            background: linear-gradient(90deg, #00d4ff, #7b2ff7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #graph-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0f1428;
        }

        #graph {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graph:active {
            cursor: grabbing;
        }

        #tooltip {
            position: absolute;
            background: rgba(20, 25, 45, 0.95);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 12px 16px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 14px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            max-width: 300px;
        }

        #tooltip.visible {
            opacity: 1;
        }

        .tooltip-row {
            margin: 4px 0;
            display: flex;
            gap: 8px;
        }

        .tooltip-label {
            font-weight: bold;
            color: #00d4ff;
            min-width: 70px;
        }

        .tooltip-value {
            color: #e0e0e0;
        }

        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 25, 45, 0.9);
            border: 2px solid #2a3f5f;
            border-radius: 8px;
            padding: 15px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #00d4ff;
            font-size: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
            font-size: 13px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #667eea;
        }

        /* Custom scrollbar for legend */
        #legend::-webkit-scrollbar {
            width: 8px;
        }

        #legend::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        #legend::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        #stats {
            background: rgba(20, 25, 45, 0.9);
            border: 2px solid #2a3f5f;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 12px;
            color: #a0a0a0;
        }
    </style>
</head>
<body>
    <div id="container">
        <header>
            <h1>Nathaniel Russell's Track Marks</h1>
            <div class="controls">
                <div id="stats"></div>
            </div>
        </header>
        <div id="graph-container">
            <svg id="graph"></svg>
            <div id="legend"></div>
            <div id="tooltip"></div>
            <div class="loading" id="loading">Loading data...</div>
        </div>
    </div>

    <script>
        // Event colors - brighter versions for dark mode
        const EVENT_COLORS = {
            "PV": "#ff4444",
            "HJ": "#ff9933",
            "LJ": "#ffff44",
            "TJ": "#f0e68c",
            "decathlon": "#ffffff",

            "60m": "#44ffff",
            "100m": "#00ffff",
            "200m": "#00bfff",
            "400m": "#4169ff",
            "600m": "#7fff00",
            "800m": "#32cd32",
            "1500m": "#9acd32",
            "5K": "#6b8e23",

            "60mH": "#e0a0e0",
            "110mH": "#da70d6",
            "300mH": "#9932cc",
            "400mH": "#ff00ff",

            "4x4": "#4169e1",
            "JT": "#d2691e",
            "HT": "#cd853f",
            "SP": "#c0c0c0",
            "DT": "#d3d3d3",
        };

        const EXCLUDE_EVENTS = ["4x4"];

        // IAAF Conversion data (abbreviated - you'll need to add the full data)
        const conversionData = {};

        // Transform state
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        let allData = [];
        let svg, tooltip;

        // Load conversion CSV and JSON data
        async function loadData() {
            try {
                // Load conversion data
                const conversionResponse = await fetch('conversion.csv');
                const conversionText = await conversionResponse.text();
                parseConversionData(conversionText);

                // Load marks data
                const [college, highSchool, unattached] = await Promise.all([
                    fetch('college_marks.json').then(r => r.json()),
                    fetch('high_school_marks.json').then(r => r.json()),
                    fetch('unnattached_marks.json').then(r => r.json())
                ]);

                const allMarks = [...college, ...highSchool, ...unattached];

                // Process marks
                allData = processMarks(allMarks);

                document.getElementById('loading').style.display = 'none';
                initializeGraph();
            } catch (error) {
                document.getElementById('loading').textContent = 'Error loading data: ' + error.message;
                console.error('Error:', error);
            }
        }

        function parseConversionData(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',');

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                const values = lines[i].split(',');
                const event = values[0];
                const sex = values[1];
                const a = parseFloat(values[2]);
                const b = parseFloat(values[3]);
                const c = parseFloat(values[4]);
                const time = values[5] === 'true';

                const key = `${sex.toUpperCase()}-${event}`;
                conversionData[key] = { a, b, c, time };
            }
        }

        function parseMark(markStr) {
            if (markStr.includes(':')) {
                const parts = markStr.split(':');
                if (parts.length === 2) {
                    return parseInt(parts[0]) * 60 + parseFloat(parts[1]);
                } else if (parts.length === 3) {
                    return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
                }
            }
            return parseFloat(markStr);
        }

        function getPoints(event, markStr, sex = 'm') {
            const key = `${sex.toUpperCase()}-${event}`;
            if (!conversionData[key]) return null;

            const table = conversionData[key];
            const mark = parseMark(markStr);

            const points = table.a * Math.pow(mark + table.b, 2) + table.c;
            return Math.floor(points);
        }

        function processMarks(marks) {
            const processed = [];

            for (const mark of marks) {
                if (EXCLUDE_EVENTS.includes(mark.event)) continue;

                const points = getPoints(mark.event, mark.mark);
                if (!points || points < 100) continue;

                const date = new Date(mark.date);
                if (isNaN(date.getTime())) continue;

                processed.push({
                    date: date,
                    points: points,
                    event: mark.event,
                    mark: mark.mark,
                    location: mark.location,
                    dateStr: mark.date
                });
            }

            processed.sort((a, b) => a.date - b.date);
            return processed;
        }

        function initializeGraph() {
            svg = document.getElementById('graph');
            tooltip = document.getElementById('tooltip');

            drawGraph();
            createLegend();
            updateStats();

            // Add event listeners
            svg.addEventListener('mousedown', onMouseDown);
            svg.addEventListener('mousemove', onMouseMove);
            svg.addEventListener('mouseup', onMouseUp);
            svg.addEventListener('mouseleave', onMouseUp);
            svg.addEventListener('wheel', onWheel);
        }

        function drawGraph() {
            const container = document.getElementById('graph-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.innerHTML = '';

            // Add defs for glow effect
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            filter.setAttribute('id', 'glow');
            filter.innerHTML = `
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            `;
            defs.appendChild(filter);
            svg.appendChild(defs);

            // Create main group for pan/zoom
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('id', 'main-group');
            svg.appendChild(g);

            if (allData.length === 0) return;

            // Calculate scales
            const margin = { top: 40, right: 40, bottom: 60, left: 80 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const minDate = allData[0].date;
            const maxDate = allData[allData.length - 1].date;
            const minPoints = Math.min(...allData.map(d => d.points));
            const maxPoints = Math.max(...allData.map(d => d.points));

            const xScale = (date) => {
                const timeRange = maxDate - minDate;
                const timeDiff = date - minDate;
                return margin.left + (timeDiff / timeRange) * chartWidth;
            };

            const yScale = (points) => {
                const pointsRange = maxPoints - minPoints;
                const pointsDiff = points - minPoints;
                return height - margin.bottom - (pointsDiff / pointsRange) * chartHeight;
            };

            // Draw grid
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gridGroup.setAttribute('class', 'grid');

            // Vertical grid lines (years)
            const yearStart = minDate.getFullYear();
            const yearEnd = maxDate.getFullYear();
            for (let year = yearStart; year <= yearEnd; year++) {
                const date = new Date(year, 0, 1);
                const x = xScale(date);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', margin.top);
                line.setAttribute('x2', x);
                line.setAttribute('y2', height - margin.bottom);
                line.setAttribute('stroke', '#2a3f5f');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('opacity', '0.3');
                gridGroup.appendChild(line);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', height - margin.bottom + 20);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', '#a0a0a0');
                text.setAttribute('font-size', '12');
                text.textContent = year;
                gridGroup.appendChild(text);
            }

            // Horizontal grid lines (points)
            const minPointsRounded = Math.floor(minPoints / 50) * 50;
            const maxPointsRounded = Math.ceil(maxPoints / 50) * 50;
            for (let points = minPointsRounded; points <= maxPointsRounded; points += 50) {
                const y = yScale(points);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', width - margin.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#2a3f5f');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('opacity', '0.3');
                gridGroup.appendChild(line);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', margin.left - 10);
                text.setAttribute('y', y + 4);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('fill', '#a0a0a0');
                text.setAttribute('font-size', '12');
                text.textContent = points;
                gridGroup.appendChild(text);
            }

            g.appendChild(gridGroup);

            // Draw data points
            const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pointsGroup.setAttribute('class', 'points');

            allData.forEach((d, i) => {
                const x = xScale(d.date);
                const y = yScale(d.points);
                const color = EVENT_COLORS[d.event] || '#c0c0c0';

                // Draw circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', 6);
                circle.setAttribute('fill', color);
                circle.setAttribute('opacity', '0.8');
                circle.setAttribute('filter', 'url(#glow)');
                circle.setAttribute('data-index', i);
                circle.style.cursor = 'pointer';

                circle.addEventListener('mouseenter', (e) => showTooltip(e, d));
                circle.addEventListener('mouseleave', hideTooltip);

                // Hover effect
                circle.addEventListener('mouseenter', () => {
                    circle.setAttribute('r', 9);
                    circle.setAttribute('opacity', '1');
                });
                circle.addEventListener('mouseleave', () => {
                    circle.setAttribute('r', 6);
                    circle.setAttribute('opacity', '0.8');
                });

                pointsGroup.appendChild(circle);

                // Add mark label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x + 8);
                text.setAttribute('y', y + 3);
                text.setAttribute('fill', '#e0e0e0');
                text.setAttribute('font-size', '9');
                text.setAttribute('opacity', '0.6');
                text.textContent = d.mark;
                pointsGroup.appendChild(text);
            });

            g.appendChild(pointsGroup);

            // Add axis labels
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', width / 2);
            xLabel.setAttribute('y', height - 10);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('fill', '#00d4ff');
            xLabel.setAttribute('font-size', '14');
            xLabel.setAttribute('font-weight', 'bold');
            xLabel.textContent = 'Date';
            g.appendChild(xLabel);

            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', -(height / 2));
            yLabel.setAttribute('y', 20);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('fill', '#00d4ff');
            yLabel.setAttribute('font-size', '14');
            yLabel.setAttribute('font-weight', 'bold');
            yLabel.setAttribute('transform', 'rotate(-90)');
            yLabel.textContent = 'World Athletics Points';
            g.appendChild(yLabel);

            applyTransform();
        }

        function createLegend() {
            const legend = document.getElementById('legend');
            const uniqueEvents = [...new Set(allData.map(d => d.event))];

            const eventOrder = [
                '60m', '100m', '200m', '400m', '600m', '800m', '1500m', '5K',
                '60mH', '110mH', '300mH', '400mH',
                'HJ', 'PV', 'LJ', 'TJ', 'SP', 'DT', 'JT', 'HT',
                'decathlon', '4x4'
            ];

            const orderedEvents = eventOrder.filter(e => uniqueEvents.includes(e));
            orderedEvents.push(...uniqueEvents.filter(e => !eventOrder.includes(e)));

            let html = '<div class="legend-title">Events</div>';
            orderedEvents.forEach(event => {
                const color = EVENT_COLORS[event] || '#c0c0c0';
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${color}; box-shadow: 0 0 8px ${color};"></div>
                        <span>${event}</span>
                    </div>
                `;
            });

            legend.innerHTML = html;
        }

        function updateStats() {
            const stats = document.getElementById('stats');
            stats.textContent = `Total marks: ${allData.length}`;
        }

        function showTooltip(event, data) {
            tooltip.innerHTML = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Event:</span>
                    <span class="tooltip-value">${data.event}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Mark:</span>
                    <span class="tooltip-value">${data.mark}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Points:</span>
                    <span class="tooltip-value">${data.points}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Date:</span>
                    <span class="tooltip-value">${data.dateStr}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Location:</span>
                    <span class="tooltip-value">${data.location}</span>
                </div>
            `;

            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY + 15) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        function applyTransform() {
            const g = document.getElementById('main-group');
            if (g) {
                g.setAttribute('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
            }
        }

        function onMouseDown(e) {
            if (e.target.tagName === 'circle') return;
            isDragging = true;
            dragStartX = e.clientX - translateX;
            dragStartY = e.clientY - translateY;
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            translateX = e.clientX - dragStartX;
            translateY = e.clientY - dragStartY;
            applyTransform();
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWheel(e) {
            e.preventDefault();

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;

            if (newScale < 0.1 || newScale > 10) return;

            const rect = svg.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            translateX = mouseX - (mouseX - translateX) * delta;
            translateY = mouseY - (mouseY - translateY) * delta;
            scale = newScale;

            applyTransform();
        }

        function resetView() {
            scale = 1;
            translateX = 0;
            translateY = 0;
            applyTransform();
        }

        function zoomIn() {
            scale *= 1.2;
            applyTransform();
        }

        function zoomOut() {
            scale *= 0.8;
            applyTransform();
        }

        // Initialize
        loadData();
    </script>
</body>
</html>
