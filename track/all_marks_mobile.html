<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Nathaniel Russell's Track Marks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d35 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: rgba(15, 20, 40, 0.95);
            padding: 12px 15px;
            border-bottom: 2px solid #2a3f5f;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        h1 {
            font-size: 20px;
            background: linear-gradient(90deg, #00d4ff, #7b2ff7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        #graph-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0f1428;
        }

        #graph {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #tooltip {
            position: fixed;
            background: rgba(20, 25, 45, 0.98);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 12px 16px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 13px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
            z-index: 2000;
            max-width: 80vw;
        }

        #tooltip.visible {
            opacity: 1;
        }

        .tooltip-row {
            margin: 4px 0;
            display: flex;
            gap: 8px;
        }

        .tooltip-label {
            font-weight: bold;
            color: #00d4ff;
            min-width: 60px;
        }

        .tooltip-value {
            color: #e0e0e0;
            word-break: break-word;
        }

        #legend-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            padding: 10px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            touch-action: manipulation;
        }

        #legend {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(20, 25, 45, 0.98);
            border: 2px solid #2a3f5f;
            border-radius: 8px;
            padding: 12px;
            max-height: 60vh;
            overflow-y: auto;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 80vw;
        }

        #legend.visible {
            transform: translateX(0);
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #00d4ff;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 12px;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            box-shadow: 0 0 6px currentColor;
            flex-shrink: 0;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #667eea;
            text-align: center;
            padding: 0 20px;
        }

        #legend::-webkit-scrollbar {
            width: 6px;
        }

        #legend::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #legend::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 3px;
        }

        #stats {
            background: rgba(20, 25, 45, 0.9);
            border: 2px solid #2a3f5f;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 11px;
            color: #a0a0a0;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 18px;
            }

            header {
                padding: 10px 12px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <header>
            <h1>Nathaniel Russell's Track Marks</h1>
            <div class="controls">
                <div id="stats"></div>
            </div>
        </header>
        <div id="graph-container">
            <svg id="graph"></svg>
            <button id="legend-toggle" onclick="toggleLegend()">Legend</button>
            <div id="legend"></div>
            <div id="tooltip"></div>
            <div class="loading" id="loading">Loading data...</div>
        </div>
    </div>

    <script>
        // Event colors - brighter versions for dark mode
        const EVENT_COLORS = {
            "PV": "#ff4444",
            "HJ": "#ff9933",
            "LJ": "#ffff44",
            "TJ": "#f0e68c",
            "decathlon": "#ffffff",

            "60m": "#44ffff",
            "100m": "#00ffff",
            "200m": "#00bfff",
            "400m": "#4169ff",
            "600m": "#7fff00",
            "800m": "#32cd32",
            "1500m": "#9acd32",
            "5K": "#6b8e23",

            "60mH": "#e0a0e0",
            "110mH": "#da70d6",
            "300mH": "#9932cc",
            "400mH": "#ff00ff",

            "4x4": "#4169e1",
            "JT": "#d2691e",
            "HT": "#cd853f",
            "SP": "#c0c0c0",
            "DT": "#d3d3d3",
        };

        const EXCLUDE_EVENTS = ["4x4"];

        // IAAF Conversion data
        const conversionData = {};

        // Transform state
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        // Touch state for pinch-to-zoom
        let touches = [];
        let lastDistance = 0;

        let allData = [];
        let svg, tooltip;

        // Load conversion CSV and JSON data
        async function loadData() {
            try {
                // Load conversion data
                const conversionResponse = await fetch('conversion.csv');
                const conversionText = await conversionResponse.text();
                parseConversionData(conversionText);

                // Load marks data
                const [college, highSchool, unattached] = await Promise.all([
                    fetch('college_marks.json').then(r => r.json()),
                    fetch('high_school_marks.json').then(r => r.json()),
                    fetch('unnattached_marks.json').then(r => r.json())
                ]);

                const allMarks = [...college, ...highSchool, ...unattached];

                // Process marks
                allData = processMarks(allMarks);

                document.getElementById('loading').style.display = 'none';
                initializeGraph();
            } catch (error) {
                document.getElementById('loading').textContent = 'Error loading data: ' + error.message;
                console.error('Error:', error);
            }
        }

        function parseConversionData(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',');

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;

                const values = lines[i].split(',');
                const event = values[0];
                const sex = values[1];
                const a = parseFloat(values[2]);
                const b = parseFloat(values[3]);
                const c = parseFloat(values[4]);
                const time = values[5] === 'true';

                const key = `${sex.toUpperCase()}-${event}`;
                conversionData[key] = { a, b, c, time };
            }
        }

        function parseMark(markStr) {
            if (markStr.includes(':')) {
                const parts = markStr.split(':');
                if (parts.length === 2) {
                    return parseInt(parts[0]) * 60 + parseFloat(parts[1]);
                } else if (parts.length === 3) {
                    return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
                }
            }
            return parseFloat(markStr);
        }

        function getPoints(event, markStr, sex = 'm') {
            const key = `${sex.toUpperCase()}-${event}`;
            if (!conversionData[key]) return null;

            const table = conversionData[key];
            const mark = parseMark(markStr);

            const points = table.a * Math.pow(mark + table.b, 2) + table.c;
            return Math.floor(points);
        }

        function processMarks(marks) {
            const processed = [];

            for (const mark of marks) {
                if (EXCLUDE_EVENTS.includes(mark.event)) continue;

                const points = getPoints(mark.event, mark.mark);
                if (!points || points < 100) continue;

                const date = new Date(mark.date);
                if (isNaN(date.getTime())) continue;

                processed.push({
                    date: date,
                    points: points,
                    event: mark.event,
                    mark: mark.mark,
                    location: mark.location,
                    dateStr: mark.date
                });
            }

            processed.sort((a, b) => a.date - b.date);
            return processed;
        }

        function initializeGraph() {
            svg = document.getElementById('graph');
            tooltip = document.getElementById('tooltip');

            drawGraph();
            createLegend();
            updateStats();

            // Add mouse event listeners (for desktop)
            svg.addEventListener('mousedown', onMouseDown);
            svg.addEventListener('mousemove', onMouseMove);
            svg.addEventListener('mouseup', onMouseUp);
            svg.addEventListener('mouseleave', onMouseUp);
            svg.addEventListener('wheel', onWheel, { passive: false });

            // Add touch event listeners (for mobile)
            svg.addEventListener('touchstart', onTouchStart, { passive: false });
            svg.addEventListener('touchmove', onTouchMove, { passive: false });
            svg.addEventListener('touchend', onTouchEnd, { passive: false });
        }

        function drawGraph() {
            const container = document.getElementById('graph-container');
            const isMobile = window.innerWidth < 768;

            // Make graph much wider on mobile for better readability
            // Use 3x viewport width on mobile, 1.5x on desktop
            const widthMultiplier = isMobile ? 3 : 1.5;
            const width = container.clientWidth * widthMultiplier;
            const height = container.clientHeight;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            svg.innerHTML = '';

            // Add defs for glow effect
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            filter.setAttribute('id', 'glow');
            filter.innerHTML = `
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            `;
            defs.appendChild(filter);
            svg.appendChild(defs);

            // Create main group for pan/zoom
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('id', 'main-group');
            svg.appendChild(g);

            if (allData.length === 0) return;

            // Calculate scales with responsive margins
            const margin = isMobile
                ? { top: 30, right: 20, bottom: 50, left: 60 }
                : { top: 40, right: 40, bottom: 60, left: 80 };

            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const minDate = allData[0].date;
            const maxDate = allData[allData.length - 1].date;
            const minPoints = Math.min(...allData.map(d => d.points));
            const maxPoints = Math.max(...allData.map(d => d.points));

            const xScale = (date) => {
                const timeRange = maxDate - minDate;
                const timeDiff = date - minDate;
                return margin.left + (timeDiff / timeRange) * chartWidth;
            };

            const yScale = (points) => {
                const pointsRange = maxPoints - minPoints;
                const pointsDiff = points - minPoints;
                return height - margin.bottom - (pointsDiff / pointsRange) * chartHeight;
            };

            // Draw grid
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gridGroup.setAttribute('class', 'grid');

            // Vertical grid lines (years)
            const yearStart = minDate.getFullYear();
            const yearEnd = maxDate.getFullYear();
            for (let year = yearStart; year <= yearEnd; year++) {
                const date = new Date(year, 0, 1);
                const x = xScale(date);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x);
                line.setAttribute('y1', margin.top);
                line.setAttribute('x2', x);
                line.setAttribute('y2', height - margin.bottom);
                line.setAttribute('stroke', '#2a3f5f');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('opacity', '0.3');
                gridGroup.appendChild(line);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', height - margin.bottom + 20);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', '#a0a0a0');
                text.setAttribute('font-size', isMobile ? '10' : '12');
                text.textContent = year;
                gridGroup.appendChild(text);
            }

            // Horizontal grid lines (points)
            const minPointsRounded = Math.floor(minPoints / 50) * 50;
            const maxPointsRounded = Math.ceil(maxPoints / 50) * 50;
            for (let points = minPointsRounded; points <= maxPointsRounded; points += 50) {
                const y = yScale(points);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', width - margin.right);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#2a3f5f');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('opacity', '0.3');
                gridGroup.appendChild(line);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', margin.left - 8);
                text.setAttribute('y', y + 4);
                text.setAttribute('text-anchor', 'end');
                text.setAttribute('fill', '#a0a0a0');
                text.setAttribute('font-size', isMobile ? '10' : '12');
                text.textContent = points;
                gridGroup.appendChild(text);
            }

            g.appendChild(gridGroup);

            // Draw data points
            const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pointsGroup.setAttribute('class', 'points');

            allData.forEach((d, i) => {
                const x = xScale(d.date);
                const y = yScale(d.points);
                const color = EVENT_COLORS[d.event] || '#c0c0c0';

                // Draw circle with larger touch target on mobile
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', isMobile ? 8 : 6);
                circle.setAttribute('fill', color);
                circle.setAttribute('opacity', '0.8');
                circle.setAttribute('filter', 'url(#glow)');
                circle.setAttribute('data-index', i);
                circle.style.cursor = 'pointer';

                // Touch events for tooltip
                circle.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showTooltipTouch(e, d);
                });

                // Mouse events for desktop
                circle.addEventListener('mouseenter', (e) => showTooltip(e, d));
                circle.addEventListener('mouseleave', hideTooltip);

                // Hover/touch effect
                circle.addEventListener('mouseenter', () => {
                    const baseSize = isMobile ? 8 : 6;
                    const hoverSize = (baseSize * 1.4) / Math.sqrt(scale);
                    circle.setAttribute('r', hoverSize);
                    circle.setAttribute('opacity', '1');
                });
                circle.addEventListener('mouseleave', () => {
                    const baseSize = isMobile ? 8 : 6;
                    const normalSize = baseSize / Math.sqrt(scale);
                    circle.setAttribute('r', normalSize);
                    circle.setAttribute('opacity', '0.8');
                });

                pointsGroup.appendChild(circle);

                // Add mark labels that scale with zoom
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x + 8);
                text.setAttribute('y', y + 3);
                text.setAttribute('fill', '#e0e0e0');
                text.setAttribute('font-size', '9');
                text.setAttribute('opacity', scale > 2 ? '0.7' : '0.3');
                text.setAttribute('data-base-x', x);
                text.setAttribute('data-base-y', y);
                text.setAttribute('data-mark-label', 'true');
                text.textContent = d.mark;
                pointsGroup.appendChild(text);
            });

            g.appendChild(pointsGroup);

            // Add axis labels
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', width / 2);
            xLabel.setAttribute('y', height - 10);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('fill', '#00d4ff');
            xLabel.setAttribute('font-size', isMobile ? '12' : '14');
            xLabel.setAttribute('font-weight', 'bold');
            xLabel.textContent = 'Date';
            g.appendChild(xLabel);

            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', -(height / 2));
            yLabel.setAttribute('y', 15);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('fill', '#00d4ff');
            yLabel.setAttribute('font-size', isMobile ? '12' : '14');
            yLabel.setAttribute('font-weight', 'bold');
            yLabel.setAttribute('transform', 'rotate(-90)');
            yLabel.textContent = 'World Athletics Points';
            g.appendChild(yLabel);

            applyTransform();
        }

        function createLegend() {
            const legend = document.getElementById('legend');
            const uniqueEvents = [...new Set(allData.map(d => d.event))];

            const eventOrder = [
                '60m', '100m', '200m', '400m', '600m', '800m', '1500m', '5K',
                '60mH', '110mH', '300mH', '400mH',
                'HJ', 'PV', 'LJ', 'TJ', 'SP', 'DT', 'JT', 'HT',
                'decathlon', '4x4'
            ];

            const orderedEvents = eventOrder.filter(e => uniqueEvents.includes(e));
            orderedEvents.push(...uniqueEvents.filter(e => !eventOrder.includes(e)));

            let html = '<div class="legend-title">Events</div>';
            orderedEvents.forEach(event => {
                const color = EVENT_COLORS[event] || '#c0c0c0';
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${color}; box-shadow: 0 0 6px ${color};"></div>
                        <span>${event}</span>
                    </div>
                `;
            });

            legend.innerHTML = html;
        }

        function toggleLegend() {
            const legend = document.getElementById('legend');
            legend.classList.toggle('visible');
        }

        function updateStats() {
            const stats = document.getElementById('stats');
            stats.textContent = `Total marks: ${allData.length}`;
        }

        function showTooltip(event, data) {
            tooltip.innerHTML = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Event:</span>
                    <span class="tooltip-value">${data.event}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Mark:</span>
                    <span class="tooltip-value">${data.mark}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Points:</span>
                    <span class="tooltip-value">${data.points}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Date:</span>
                    <span class="tooltip-value">${data.dateStr}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Location:</span>
                    <span class="tooltip-value">${data.location}</span>
                </div>
            `;

            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY + 15) + 'px';
            tooltip.classList.add('visible');
        }

        function showTooltipTouch(event, data) {
            const touch = event.touches[0];

            tooltip.innerHTML = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Event:</span>
                    <span class="tooltip-value">${data.event}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Mark:</span>
                    <span class="tooltip-value">${data.mark}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Points:</span>
                    <span class="tooltip-value">${data.points}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Date:</span>
                    <span class="tooltip-value">${data.dateStr}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Location:</span>
                    <span class="tooltip-value">${data.location}</span>
                </div>
            `;

            // Position tooltip to avoid going off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            let left = touch.pageX + 15;
            let top = touch.pageY - tooltipRect.height - 15;

            // Adjust if going off right edge
            if (left + tooltipRect.width > window.innerWidth) {
                left = touch.pageX - tooltipRect.width - 15;
            }

            // Adjust if going off top edge
            if (top < 0) {
                top = touch.pageY + 15;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.classList.add('visible');

            // Auto-hide tooltip after 3 seconds
            setTimeout(hideTooltip, 3000);
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        function applyTransform() {
            const g = document.getElementById('main-group');
            if (g) {
                g.setAttribute('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
            }

            // Adjust circle sizes inversely to zoom level to prevent overlap
            const circles = document.querySelectorAll('circle[data-index]');
            const isMobile = window.innerWidth < 768;
            const baseSize = isMobile ? 8 : 6;
            const newRadius = baseSize / Math.sqrt(scale);

            circles.forEach(circle => {
                circle.setAttribute('r', newRadius);
            });

            // Adjust mark label sizes and positions to scale with zoom
            const labels = document.querySelectorAll('text[data-mark-label]');
            const baseFontSize = 9;
            const newFontSize = baseFontSize / Math.sqrt(scale);
            const offsetX = 8 / Math.sqrt(scale);
            const offsetY = 3 / Math.sqrt(scale);

            labels.forEach(label => {
                const baseX = parseFloat(label.getAttribute('data-base-x'));
                const baseY = parseFloat(label.getAttribute('data-base-y'));

                label.setAttribute('font-size', newFontSize);
                label.setAttribute('x', baseX + offsetX);
                label.setAttribute('y', baseY + offsetY);

                // Show labels more prominently when zoomed in
                if (scale > 2) {
                    label.setAttribute('opacity', '0.7');
                } else if (scale > 1) {
                    label.setAttribute('opacity', '0.5');
                } else {
                    label.setAttribute('opacity', '0.3');
                }
            });
        }

        // Mouse events (desktop)
        function onMouseDown(e) {
            if (e.target.tagName === 'circle') return;
            isDragging = true;
            dragStartX = e.clientX - translateX;
            dragStartY = e.clientY - translateY;
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            translateX = e.clientX - dragStartX;
            translateY = e.clientY - dragStartY;
            applyTransform();
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWheel(e) {
            e.preventDefault();

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;

            if (newScale < 0.1 || newScale > 50) return;

            // Get mouse position in SVG coordinates
            const point = svg.createSVGPoint();
            point.x = e.clientX;
            point.y = e.clientY;
            const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());

            // Get the point in the current transform space
            const g = document.getElementById('main-group');
            const transform = g.getScreenCTM();
            const beforeZoom = point.matrixTransform(transform.inverse());

            scale = newScale;
            applyTransform();

            // Get the point after zoom
            const afterTransform = g.getScreenCTM();
            const afterZoom = point.matrixTransform(afterTransform.inverse());

            // Adjust translation to keep the point under the cursor
            translateX += (afterZoom.x - beforeZoom.x) * scale;
            translateY += (afterZoom.y - beforeZoom.y) * scale;

            applyTransform();
        }

        // Touch events (mobile)
        function onTouchStart(e) {
            // Hide tooltip on new touch
            hideTooltip();

            if (e.target.tagName === 'circle') {
                return; // Let circle handle its own touch
            }

            touches = Array.from(e.touches);

            if (touches.length === 1) {
                // Single finger pan
                isDragging = true;
                dragStartX = touches[0].clientX - translateX;
                dragStartY = touches[0].clientY - translateY;
            } else if (touches.length === 2) {
                // Two finger pinch-to-zoom
                isDragging = false;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                lastDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }

        function onTouchMove(e) {
            e.preventDefault();

            touches = Array.from(e.touches);

            if (touches.length === 1 && isDragging) {
                // Single finger pan
                translateX = touches[0].clientX - dragStartX;
                translateY = touches[0].clientY - dragStartY;
                applyTransform();
            } else if (touches.length === 2) {
                // Two finger pinch-to-zoom
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (lastDistance > 0) {
                    const delta = distance / lastDistance;
                    const newScale = scale * delta;

                    if (newScale >= 0.1 && newScale <= 50) {
                        // Calculate center point between fingers in screen coordinates
                        const centerScreenX = (touches[0].clientX + touches[1].clientX) / 2;
                        const centerScreenY = (touches[0].clientY + touches[1].clientY) / 2;

                        // Get center point in SVG coordinates
                        const point = svg.createSVGPoint();
                        point.x = centerScreenX;
                        point.y = centerScreenY;

                        // Get the point in the current transform space
                        const g = document.getElementById('main-group');
                        const transform = g.getScreenCTM();
                        const beforeZoom = point.matrixTransform(transform.inverse());

                        scale = newScale;
                        applyTransform();

                        // Get the point after zoom
                        const afterTransform = g.getScreenCTM();
                        const afterZoom = point.matrixTransform(afterTransform.inverse());

                        // Adjust translation to keep the point under the fingers
                        translateX += (afterZoom.x - beforeZoom.x) * scale;
                        translateY += (afterZoom.y - beforeZoom.y) * scale;

                        applyTransform();
                    }
                }

                lastDistance = distance;
            }
        }

        function onTouchEnd(e) {
            touches = Array.from(e.touches);

            if (touches.length === 0) {
                isDragging = false;
                lastDistance = 0;
            } else if (touches.length === 1) {
                // Reset for single finger pan
                isDragging = true;
                dragStartX = touches[0].clientX - translateX;
                dragStartY = touches[0].clientY - translateY;
                lastDistance = 0;
            }
        }

        // Initialize
        loadData();

        // Redraw on orientation change
        window.addEventListener('resize', () => {
            drawGraph();
        });
    </script>
</body>
</html>
